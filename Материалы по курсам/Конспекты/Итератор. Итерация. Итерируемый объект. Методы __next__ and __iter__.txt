    Итерируемый объект — это объект, который можно перебирать Это списки, кортежи и
тд., а также экземпляры класса, если в классе реализован метод __iter__()
    Итерация — это процесс обхода элементов итерируемого объекта. 
В Python для этого обычно используется цикл for.

Определения итератора:
    Итератор — это некий объект, который в себе реализует интерфейс перебора чего-либо
    Итератор - это объект, который позволяет перемещаться (итерироваться) по элементам некоторой последовательности.

Самое простое определение:
    Итератор - это такая штука, которая в себе описывает правило, по которому мы будем перебирать 
содержимое того или иного объекта.

    Во многих статьях и книгах пишут про то, что цикл for позволяет перебирать объекты коллекций.
Это правда. Однако часто из внимания упускают то, как именно он это делает.
На самом деле цикл for взаимодействует не с самим целевым объектом перебора, а с его итератором.
То есть цикл как бы говорит: «Эй, объект! Я хочу тебя перебрать, поэтому дай мне то, что описывает правило твоего перебора!»
Если цикл получает итератор, то все в порядке - начинается перебор элементов последовательности, а если объект не возвращает
итератор, то цикл не может его перебрать и у нас высвечивается ошибка.

    Цикл for получает объект-итератор от итерируемого объекта с помощью неявного вызова встроенной функции iter, 
в которую, в качестве аргумента, он передаёт как раз этот самый итерируемый объект.
Пример для понятности: 

>>> print(iter(<в данном случае тут список>))
<list_iterator object at 0x10d4c53d0> # это итератор некоторого списка:)

    Мы получили объект типа list_iterator, содержащий в себе то самое правило перебора, которое будет применяться.

    А сам перебор осуществляется посредством тупого нажатия кнопки "дальше", пока цикл не встретит "хватит".
В данном случае кнопкой является функция next, аргументом которой является объект-итератор, полученный на предыдущем шаге,
а в роли хватит выступает raise ошибки "StopIteration".

    То есть ответственность за перебор лежит не на цикле for (он просто запрашивает итератор и жмëт в нëм кнопку)
и не на самом итерируемом объекте (он лишь должен отдавать свой объект-итератор по запросу), а на итераторе!

Методы:
1).__iter__():
 По умолчанию в нами созданном классе, класс понятия не имеет, кто отвечает за правило перебора элементов в нем. 
Эту проблему и решает магический метод __iter__, назначение которого как раз и состоит в том, чтобы создавать и 
возвращать в результате своей работы некий объект-итератор.

Т.е. в случае с кастомным классом, цикл for, к примеру, вызывает функцию iter(), а
эта функция iter() идет в сам класс находит там метод __iter__(...) и возращает результат его работы
 
2).__next__():
    Мы не можем вернуть итератор с помощью функции __iter__, если итератор не является итератором.
Он как бы не создан, но мы уже стремимся его вернуть. А что является, спросите вы? 
А является итератором то, что обладает специальным магическим методом, способным возвращать очередное значение. 
Именно возвращать очередное значение! Таким магическим методом является метод __next__.

    Этот метод будет отрабатывать каждый раз, когда объект итератора будет передаваться во встроенную функцию next.

По материалам:
Итератор: https://habr.com/ru/companies/domclick/articles/674194/  - обязательно к многократному прочтению